import numpy as np
import sklearn
import sklearn.preprocessing
from sklearn.utils import check_random_state
from skimage.color import gray2rgb
from skimage.segmentation import quickshift, slic
import copy

from lime_sk import Lime


class ImageExplanation(object):
    """ Returns image and mask for visualization """
    def __init__(self, image, segments):
        """
        Args:
            image: 3d numpy array
            segments: 2d numpy array, with the output from skimage.segmentation
        """
        self.image = image            # image to be processed
        self.segments = segments      # superpixels
        self.local_explanation = None # weights for each superpixel within certain class
        self.score = None             # scoring of goodness of g(x)


    def get_image_and_mask(self, positive_only=True, hide_rest=False,
                           num_features=5, min_weight=0.):
        """
        Constructs image and mask to visualize explanation

        Args:
            positive_only: if True, only take superpixels that contribute to
                the prediction of the label. Otherwise, use the top
                num_features superpixels, which can be positive or negative
                towards the label
            hide_rest: if True, make the non-explanation part of the return
                image gray
            num_features: number of superpixels to include in explanation
            min_weight: min_weight for the superpixel
        Returns:
            (image, mask), where image is a 3d numpy array and mask is a 2d
            numpy array
        """

        segments = self.segments
        image = self.image
        explanation = self.local_explanation  # explanation of the particular label
        mask = np.zeros(segments.shape, segments.dtype)

        # show or hide original image
        if hide_rest:
            bg = np.zeros(self.image.shape)
        else:
            bg = self.image.copy()

        # look for maximum positive and minimum negative weigth
        weights = [x[1] for x in explanation]
        weights = np.array(weights)

        max_pos_w = np.max(weights)
        min_neg_w = np.max(-weights)

        # show or hide negative contributions
        if positive_only:
            # list of superpixel indices
            positive_weights_index = [x[0] for x in explanation
                                      if x[1] > 0 and x[1] > min_weight][:num_features]
            for ind in positive_weights_index:
                # activate image parts which correspond to the positively
                # weighted superpixels
                bg[segments == ind] = image[segments == ind].copy()
                mask[segments == ind] = 1
            return bg, mask
        else:
            for ind, w in explanation[:num_features]:
                if np.abs(w) < min_weight:
                    continue # skip superpixels with small weights
                # channels
                # red = img[:, :, 0]
                # green = img[:, :, 1]
                # blue = img[:, :, 2]
                if w < 0:
                    c = 0
#                 norm = min_neg_w
                else:
                    c = 1
#                 norm = max_pos_w
                norm = max_pos_w
                mask[segments == ind] = 1 if w < 0 else 2
                bg[segments == ind] = 0.
                bg[segments == ind, c] = np.max(image)*abs(w)/norm
            return bg, mask

class ImageExplainer(object):
    """Explains predictions on Image data."""

    def __init__(self, label=None, distance='cosine', kernel_width=.25, random_state=None):
        """
        Args:
            label: label which we want to explain
            distance: the distance metric to use for weights.
            kernel_width: kernel width for the exponential kernel.
            random_state: an integer or numpy.RandomState that is used to
                generate random numbers.
        """
        # Turn seed into a np.random.RandomState instance
        self.random_state = check_random_state(random_state)
        self.label = label
        self.base = Lime(distance=distance, kernel_width=kernel_width) #, random_state=self.random_state)

    def explain_prediction(self, image,
                           clf_model,
                           hide_color=None,
                           num_features=None,
                           num_samples=1000,
                           random_seed=None):

        """
        Generates explanations for a prediction.
        First, neighborhood data is generated by randomly activating features
        from the instance. Then locally weighted linear model is learned
        on this neighborhood data to explain each of the classes.
        ============================
        Args:
            image: 3 dimension RGB image
            clf_model: classifier prediction probability function, which
                takes a numpy array and outputs prediction probabilities.
                Ex: inet_model.predict
            hide_color: constant value to assign to each pixel at the image
            num_features: maximum number of features present in explanation (K in the paper)
            num_samples: size of the neighborhood to learn the linear model

            random_seed: integer used as random seed for the segmentation algorithm.
        Returns:
            An Explanation object with the corresponding explanations.
        """
        if len(image.shape) == 2:
            image = gray2rgb(image)
        if random_seed is None:
            random_seed = self.random_state.randint(0, high=1000)

        # Segmentation of the image -------------------------------
        # we use Quick Shift algorithm for segmentation
        # segments = quickshift(image, kernel_size=4, max_dist=200, ratio=0.2, random_seed=random_seed)
        # we can also try SLIC
        segments = slic(image, n_segments=100, compactness=20, sigma=1)

        # Create basement for further sampling ---------------------
        bg_image = image.copy()  # basement for further sampling
        if hide_color is None:
            # average over pixels within a superpixel separately over each channel
            for x in np.unique(segments):
                bg_image[segments == x] = (
                    np.mean(image[segments == x][:, 0]),
                    np.mean(image[segments == x][:, 1]),
                    np.mean(image[segments == x][:, 2]))
        else:
            # put single constant value for all pixels
            bg_image[:] = hide_color

        # Turn on all superpixels for original sample
        features = np.ones(np.unique(segments).size)

        if num_features is None:
            num_features = np.unique(segments).size

        result = ImageExplanation(image, segments)

        model = lambda x: self.sampling_pred(x, self.label, image, bg_image, segments, clf_model)

        result.local_explanation, result.score = self.base.explain(
                                                    features=features,
                                                    model=model,
                                                    n=num_samples,
                                                    n_features=num_features
                                                    )

        return result


    def sampling_pred(self, data, label,
                      image, bg_image, segments, clf_model):
        """
        gives prediction for the particular class = label
        for a sample generated by data vector
        ===========================
        Args:
                data: vector of shape = features.shape, which
                    contains 0 and 1, where 0 correspond to the
                    feature being excluded
                label: class label which we want to obtain prediction for
                image: original input image
                bg_image: basement for sampling
                segments: image segmentation
                clf_model: classifier
        Returns:
                prediction of label for newly generated sample

        """

        # Obtain new sample
        temp = image.copy()
        zeros = np.where(data == 0)[0] # list of indeces where element = 0
        mask = np.zeros(segments.shape).astype(bool)
        for ind in zeros:
            mask[segments == ind] = True
        # mask is of the same shape as segment
        # True is put where superpixel is turned off
        temp[mask] = bg_image[mask] # put base image where superpixel off
        img = temp[np.newaxis, :]
        predictions = clf_model(img)

        return predictions[0, label]
